--- busybox-1.00-pre4.ORIG/include/applets.h	2003-11-14 04:04:33.000000000 -0600
+++ busybox-1.00-pre4/include/applets.h	2003-12-17 11:06:20.000000000 -0600
@@ -75,6 +75,9 @@
 #ifdef CONFIG_BASENAME
 	APPLET(basename, basename_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
 #endif
+#ifdef CONFIG_BRCTL
+	APPLET(brctl, brctl_main, _BB_DIR_SBIN, _BB_SUID_NEVER)
+#endif
 #ifdef CONFIG_BUNZIP2
 	APPLET(bunzip2, bunzip2_main, _BB_DIR_USR_BIN, _BB_SUID_NEVER)
 #endif
--- busybox-1.00-pre4.ORIG/include/usage.h	2003-12-10 19:18:07.000000000 -0600
+++ busybox-1.00-pre4/include/usage.h	2003-12-17 11:06:20.000000000 -0600
@@ -80,6 +80,28 @@
 	"$ basename /foo/bar.txt .txt\n" \
 	"bar"
 
+#define brctl_trivial_usage \
+	"COMMAND [OPTIONS]"
+#define brctl_full_usage \
+	"Create, delete and configue ethernet bridge.\n\n" \
+	"Commands:\n" \
+	"\taddbr\t\t<bridge>\t\tadd bridge\n" \
+	"\taddif\t\t<bridge> <device>\tadd interface to bridge\n" \
+	"\tdelbr\t\t<bridge>\t\tdelete bridge\n" \
+	"\tdelif\t\t<bridge> <device>\tdelete interface from bridge\n" \
+	"\tshow\t\t\t\t\tshow a list of bridges\n" \
+	"\tshowmacs\t<bridge>\t\tshow a list of mac addrs\n" \
+	"\tshowstp\t\t<bridge>\t\tshow bridge stp info\n" \
+	"\tsetageing\t<bridge> <time>\t\tset ageing time\n" \
+	"\tsetbridgeprio\t<bridge> <prio>\t\tset bridge priority\n" \
+	"\tsetfd\t\t<bridge> <time>\t\tset bridge forward delay\n" \
+	"\tsetgcint\t<bridge> <time>\t\tset garbage collection interval\n" \
+	"\tsethello\t<bridge> <time>\t\tset hello time\n" \
+	"\tsetmaxage\t<bridge> <time>\t\tset max message age\n" \
+	"\tsetpathcost\t<bridge> <port> <cost>\tset path cost\n" \
+	"\tsetportprio\t<bridge> <port> <prio>\tset port priority\n" \
+	"\tstp\t\t<bridge> <state>\tturn stp on/off\n"
+
 #define bunzip2_trivial_usage \
 	"[OPTION]... [FILE]"
 #define bunzip2_full_usage \
--- busybox-1.00-pre4.ORIG/Makefile	2003-11-17 04:26:43.000000000 -0600
+++ busybox-1.00-pre4/Makefile	2003-12-17 11:06:20.000000000 -0600
@@ -28,7 +28,7 @@
 
 DIRS:=applets archival archival/libunarchive coreutils console-tools \
 	debianutils editors findutils init miscutils modutils networking \
-	networking/libiproute networking/udhcp procps loginutils shell \
+	networking/libiproute networking/libbridge networking/udhcp procps loginutils shell \
 	sysklogd util-linux libpwdgrp coreutils/libcoreutils libbb
 
 ifeq ($(strip $(CONFIG_SELINUX)),y)
--- busybox-1.00-pre4.ORIG/networking/brctl.c	1969-12-31 18:00:00.000000000 -0600
+++ busybox-1.00-pre4/networking/brctl.c	2003-12-17 12:49:51.000000000 -0600
@@ -0,0 +1,507 @@
+/*
+ * Copyright (C) 2000 Lennert Buytenhek
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <errno.h>
+#include <sys/time.h>
+#include <asm/param.h>
+#include "libbridge/libbridge.h"
+#include "libbridge/brctl.h"
+#include "busybox.h"
+
+void br_dump_bridge_id(unsigned char *x)
+{
+	printf("%.2x%.2x.%.2x%.2x%.2x%.2x%.2x%.2x", x[0], x[1], x[2], x[3],
+		   x[4], x[5], x[6], x[7]);
+}
+
+void br_show_timer(struct timeval *tv)
+{
+	printf("%4i.%.2i", (int) tv->tv_sec, (int) tv->tv_usec / 10000);
+}
+
+void br_dump_interface_list(struct bridge *br)
+{
+	char ifname[IFNAMSIZ];
+	struct port *p;
+
+	p = br->firstport;
+	if (p != NULL) {
+		printf("%s", if_indextoname(p->ifindex, ifname));
+		p = p->next;
+	}
+	printf("\n");
+
+	while (p != NULL) {
+		printf("\t\t\t\t\t\t\t%s\n", if_indextoname(p->ifindex, ifname));
+		p = p->next;
+	}
+}
+
+void br_dump_port_info(struct port *p)
+{
+	char ifname[IFNAMSIZ];
+	struct port_info *pi;
+
+	pi = &p->info;
+
+	printf("%s (%i)\n", if_indextoname(p->ifindex, ifname), p->index);
+	printf(" port id\t\t%.4x\t\t\t", pi->port_id);
+	printf("state\t\t\t%s\n", br_get_state_name(pi->state));
+	printf(" designated root\t");
+	br_dump_bridge_id((unsigned char *) &pi->designated_root);
+	printf("\tpath cost\t\t%4i\n", pi->path_cost);
+
+	printf(" designated bridge\t");
+	br_dump_bridge_id((unsigned char *) &pi->designated_bridge);
+	printf("\tmessage age timer\t");
+	br_show_timer(&pi->message_age_timer_value);
+	printf("\n designated port\t%.4x", pi->designated_port);
+	printf("\t\t\tforward delay timer\t");
+	br_show_timer(&pi->forward_delay_timer_value);
+	printf("\n designated cost\t%4i", pi->designated_cost);
+	printf("\t\t\thold timer\t\t");
+	br_show_timer(&pi->hold_timer_value);
+	printf("\n flags\t\t\t");
+	if (pi->config_pending)
+		printf("CONFIG_PENDING ");
+	if (pi->top_change_ack)
+		printf("TOPOLOGY_CHANGE_ACK ");
+	printf("\n");
+	printf("\n");
+}
+
+void br_dump_info(struct bridge *br)
+{
+	struct bridge_info *bri;
+	struct port *p;
+
+	bri = &br->info;
+
+	printf("%s\n", br->ifname);
+	if (!bri->stp_enabled) {
+		printf(" STP is disabled for this interface\n");
+		return;
+	}
+
+	printf(" bridge id\t\t");
+	br_dump_bridge_id((unsigned char *) &bri->bridge_id);
+	printf("\n designated root\t");
+	br_dump_bridge_id((unsigned char *) &bri->designated_root);
+	printf("\n root port\t\t%4i\t\t\t", bri->root_port);
+	printf("path cost\t\t%4i\n", bri->root_path_cost);
+	printf(" max age\t\t");
+	br_show_timer(&bri->max_age);
+	printf("\t\t\tbridge max age\t\t");
+	br_show_timer(&bri->bridge_max_age);
+	printf("\n hello time\t\t");
+	br_show_timer(&bri->hello_time);
+	printf("\t\t\tbridge hello time\t");
+	br_show_timer(&bri->bridge_hello_time);
+	printf("\n forward delay\t\t");
+	br_show_timer(&bri->forward_delay);
+	printf("\t\t\tbridge forward delay\t");
+	br_show_timer(&bri->bridge_forward_delay);
+	printf("\n ageing time\t\t");
+	br_show_timer(&bri->ageing_time);
+	printf("\t\t\tgc interval\t\t");
+	br_show_timer(&bri->gc_interval);
+	printf("\n hello timer\t\t");
+	br_show_timer(&bri->hello_timer_value);
+	printf("\t\t\ttcn timer\t\t");
+	br_show_timer(&bri->tcn_timer_value);
+	printf("\n topology change timer\t");
+	br_show_timer(&bri->topology_change_timer_value);
+	printf("\t\t\tgc timer\t\t");
+	br_show_timer(&bri->gc_timer_value);
+	printf("\n flags\t\t\t");
+	if (bri->topology_change)
+		printf("TOPOLOGY_CHANGE ");
+	if (bri->topology_change_detected)
+		printf("TOPOLOGY_CHANGE_DETECTED ");
+	printf("\n");
+	printf("\n");
+	printf("\n");
+
+	p = br->firstport;
+	while (p != NULL) {
+		br_dump_port_info(p);
+		p = p->next;
+	}
+}
+
+
+void br_cmd_addbr(struct bridge *br, char *brname, char *arg1)
+{
+	int err;
+
+	if ((err = br_add_bridge(brname)) == 0)
+		return;
+
+	switch (err) {
+	case EEXIST:
+		fprintf(stderr, "device %s already exists; can't create "
+				"bridge with the same name\n", brname);
+		break;
+
+	default:
+		perror("br_add_bridge");
+		break;
+	}
+}
+
+void br_cmd_delbr(struct bridge *br, char *brname, char *arg1)
+{
+	int err;
+
+	if ((err = br_del_bridge(brname)) == 0)
+		return;
+
+	switch (err) {
+	case ENXIO:
+		fprintf(stderr, "bridge %s doesn't exist; can't delete it\n", brname);
+		break;
+
+	case EBUSY:
+		fprintf(stderr, "bridge %s is still up; can't delete it\n", brname);
+		break;
+
+	default:
+		perror("br_del_bridge");
+		break;
+	}
+}
+
+void br_cmd_addif(struct bridge *br, char *ifname, char *arg1)
+{
+	int err;
+	int ifindex;
+
+	ifindex = if_nametoindex(ifname);
+	if (!ifindex) {
+		fprintf(stderr, "interface %s does not exist!\n", ifname);
+		return;
+	}
+
+	if ((err = br_add_interface(br, ifindex)) == 0)
+		return;
+
+	switch (err) {
+	case EBUSY:
+		fprintf(stderr, "device %s is already a member of a bridge; "
+				"can't enslave it to bridge %s.\n", ifname, br->ifname);
+		break;
+
+	case ELOOP:
+		fprintf(stderr, "device %s is a bridge device itself; "
+				"can't enslave a bridge device to a bridge device.\n",
+				ifname);
+		break;
+
+	default:
+		perror("br_add_interface");
+		break;
+	}
+}
+
+void br_cmd_delif(struct bridge *br, char *ifname, char *arg1)
+{
+	int err;
+	int ifindex;
+
+	ifindex = if_nametoindex(ifname);
+	if (!ifindex) {
+		fprintf(stderr, "interface %s does not exist!\n", ifname);
+		return;
+	}
+
+	if ((err = br_del_interface(br, ifindex)) == 0)
+		return;
+
+	switch (err) {
+	case EINVAL:
+		fprintf(stderr, "device %s is not a slave of %s\n",
+				ifname, br->ifname);
+		break;
+
+	default:
+		perror("br_del_interface");
+		break;
+	}
+}
+
+void br_cmd_setageing(struct bridge *br, char *time, char *arg1)
+{
+	double secs;
+	struct timeval tv;
+
+	sscanf(time, "%lf", &secs);
+	tv.tv_sec = secs;
+	tv.tv_usec = 1000000 * (secs - tv.tv_sec);
+	br_set_ageing_time(br, &tv);
+}
+
+void br_cmd_setbridgeprio(struct bridge *br, char *_prio, char *arg1)
+{
+	int prio;
+
+	sscanf(_prio, "%i", &prio);
+	br_set_bridge_priority(br, prio);
+}
+
+void br_cmd_setfd(struct bridge *br, char *time, char *arg1)
+{
+	double secs;
+	struct timeval tv;
+
+	sscanf(time, "%lf", &secs);
+	tv.tv_sec = secs;
+	tv.tv_usec = 1000000 * (secs - tv.tv_sec);
+	br_set_bridge_forward_delay(br, &tv);
+}
+
+void br_cmd_setgcint(struct bridge *br, char *time, char *arg1)
+{
+	double secs;
+	struct timeval tv;
+
+	sscanf(time, "%lf", &secs);
+	tv.tv_sec = secs;
+	tv.tv_usec = 1000000 * (secs - tv.tv_sec);
+	br_set_gc_interval(br, &tv);
+}
+
+void br_cmd_sethello(struct bridge *br, char *time, char *arg1)
+{
+	double secs;
+	struct timeval tv;
+
+	sscanf(time, "%lf", &secs);
+	tv.tv_sec = secs;
+	tv.tv_usec = 1000000 * (secs - tv.tv_sec);
+	br_set_bridge_hello_time(br, &tv);
+}
+
+void br_cmd_setmaxage(struct bridge *br, char *time, char *arg1)
+{
+	double secs;
+	struct timeval tv;
+
+	sscanf(time, "%lf", &secs);
+	tv.tv_sec = secs;
+	tv.tv_usec = 1000000 * (secs - tv.tv_sec);
+	br_set_bridge_max_age(br, &tv);
+}
+
+void br_cmd_setpathcost(struct bridge *br, char *arg0, char *arg1)
+{
+	int cost;
+	struct port *p;
+
+	if ((p = br_find_port(br, arg0)) == NULL) {
+		fprintf(stderr, "can't find port %s in bridge %s\n", arg0,
+				br->ifname);
+		return;
+	}
+
+	sscanf(arg1, "%i", &cost);
+	br_set_path_cost(p, cost);
+}
+
+void br_cmd_setportprio(struct bridge *br, char *arg0, char *arg1)
+{
+	int cost;
+	struct port *p;
+
+	if ((p = br_find_port(br, arg0)) == NULL) {
+		fprintf(stderr, "can't find port %s in bridge %s\n", arg0,
+				br->ifname);
+		return;
+	}
+
+	sscanf(arg1, "%i", &cost);
+	br_set_port_priority(p, cost);
+}
+
+void br_cmd_stp(struct bridge *br, char *arg0, char *arg1)
+{
+	int stp;
+
+	stp = 0;
+	if (!strcmp(arg0, "on") || !strcmp(arg0, "yes") || !strcmp(arg0, "1"))
+		stp = 1;
+
+	br_set_stp_state(br, stp);
+}
+
+void br_cmd_showstp(struct bridge *br, char *arg0, char *arg1)
+{
+	br_dump_info(br);
+}
+
+void br_cmd_show(struct bridge *br, char *arg0, char *arg1)
+{
+	printf("bridge name\tbridge id\t\tSTP enabled\tinterfaces\n");
+	br = bridge_list;
+	while (br != NULL) {
+		printf("%s\t\t", br->ifname);
+		br_dump_bridge_id((unsigned char *) &br->info.bridge_id);
+		printf("\t%s\t\t", br->info.stp_enabled ? "yes" : "no");
+		br_dump_interface_list(br);
+
+		br = br->next;
+	}
+}
+
+static int compare_fdbs(const void *_f0, const void *_f1)
+{
+	const struct fdb_entry *f0 = _f0;
+	const struct fdb_entry *f1 = _f1;
+
+#if 0
+	if (f0->port_no < f1->port_no)
+		return -1;
+
+	if (f0->port_no > f1->port_no)
+		return 1;
+#endif
+
+	return memcmp(f0->mac_addr, f1->mac_addr, 6);
+}
+
+void __dump_fdb_entry(struct fdb_entry *f)
+{
+	printf("%3i\t", f->port_no);
+	printf("%.2x:%.2x:%.2x:%.2x:%.2x:%.2x\t",
+		   f->mac_addr[0], f->mac_addr[1], f->mac_addr[2],
+		   f->mac_addr[3], f->mac_addr[4], f->mac_addr[5]);
+	printf("%s\t\t", f->is_local ? "yes" : "no");
+	br_show_timer(&f->ageing_timer_value);
+	printf("\n");
+}
+
+void br_cmd_showmacs(struct bridge *br, char *arg0, char *arg1)
+{
+	struct fdb_entry fdb[1024];
+	int offset;
+
+	printf("port\tmac addr\t\tlocal\tageing timer\n");
+
+	offset = 0;
+	while (1) {
+		int i;
+		int num;
+
+		num = br_read_fdb(br, fdb, offset, 1024);
+		if (!num)
+			break;
+
+		qsort(fdb, num, sizeof(struct fdb_entry), compare_fdbs);
+
+		for (i = 0; i < num; i++)
+			__dump_fdb_entry(fdb + i);
+
+		offset += num;
+	}
+}
+
+static struct command commands[] = {
+	{0, 1, "addbr", br_cmd_addbr},
+	{1, 1, "addif", br_cmd_addif},
+	{0, 1, "delbr", br_cmd_delbr},
+	{1, 1, "delif", br_cmd_delif},
+	{1, 1, "setageing", br_cmd_setageing},
+	{1, 1, "setbridgeprio", br_cmd_setbridgeprio},
+	{1, 1, "setfd", br_cmd_setfd},
+	{1, 1, "setgcint", br_cmd_setgcint},
+	{1, 1, "sethello", br_cmd_sethello},
+	{1, 1, "setmaxage", br_cmd_setmaxage},
+	{1, 2, "setpathcost", br_cmd_setpathcost},
+	{1, 2, "setportprio", br_cmd_setportprio},
+	{0, 0, "show", br_cmd_show},
+	{1, 0, "showmacs", br_cmd_showmacs},
+	{1, 0, "showstp", br_cmd_showstp},
+	{1, 1, "stp", br_cmd_stp},
+};
+
+struct command *br_command_lookup(char *cmd)
+{
+	int i;
+	int numcommands;
+
+	numcommands = sizeof(commands) / sizeof(commands[0]);
+
+	for (i = 0; i < numcommands; i++)
+		if (!strcmp(cmd, commands[i].name))
+			return &commands[i];
+
+	return NULL;
+}
+
+
+
+int brctl_main(int argc, char *argv[])
+{
+	int argindex;
+	struct bridge *br;
+	struct command *cmd;
+
+	br_init();
+
+	if (argc < 2)
+		goto help;
+
+	if ((cmd = br_command_lookup(argv[1])) == NULL) {
+		fprintf(stderr, "never heard of command [%s]\n", argv[1]);
+		goto help;
+	}
+
+	argindex = 2;
+	br = NULL;
+	if (cmd->needs_bridge_argument) {
+		if (argindex >= argc) {
+			fprintf(stderr,
+					"this option requires a bridge name as argument\n");
+			return 1;
+		}
+
+		br = br_find_bridge(argv[argindex]);
+
+		if (br == NULL) {
+			fprintf(stderr, "bridge %s doesn't exist!\n", argv[argindex]);
+			return 1;
+		}
+
+		argindex++;
+	}
+
+	if (argc - argindex != cmd->num_string_arguments) {
+		fprintf(stderr, "incorrect number of arguments for command\n");
+		return 1;
+	}
+
+	cmd->func(br, argv[argindex], argv[argindex + 1]);
+
+	return 0;
+
+  help:
+	bb_show_usage();
+	return 1;
+}
--- busybox-1.00-pre4.ORIG/networking/Config.in	2003-10-22 04:58:33.000000000 -0500
+++ busybox-1.00-pre4/networking/Config.in	2003-12-17 11:06:20.000000000 -0600
@@ -18,6 +18,12 @@
 	help
 	  Ping hosts by ARP packets
 
+config CONFIG_BRCTL
+	bool "brctl"
+	default n
+	help
+	  Configure ethernet bridge
+
 config CONFIG_FTPGET
 	bool "ftpget"
 	default n
--- busybox-1.00-pre4.ORIG/networking/libbridge/brctl.h	1969-12-31 18:00:00.000000000 -0600
+++ busybox-1.00-pre4/networking/libbridge/brctl.h	2003-12-17 11:06:20.000000000 -0600
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2000 Lennert Buytenhek
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef _BRCTL_H
+#define _BRCTL_H
+
+struct command {
+	int needs_bridge_argument;
+	int num_string_arguments;
+	char *name;
+	void (*func) (struct bridge * br, char *arg0, char *arg1);
+};
+
+struct command *br_command_lookup(char *cmd);
+void br_dump_bridge_id(unsigned char *x);
+void br_show_timer(struct timeval *tv);
+void br_dump_interface_list(struct bridge *br);
+void br_dump_port_info(struct port *p);
+void br_dump_info(struct bridge *br);
+
+#endif
--- busybox-1.00-pre4.ORIG/networking/libbridge/if_index.c	1969-12-31 18:00:00.000000000 -0600
+++ busybox-1.00-pre4/networking/libbridge/if_index.c	2003-12-17 11:06:20.000000000 -0600
@@ -0,0 +1,238 @@
+/* Copyright (C) 1997, 1998, 1999 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <errno.h>
+#include <string.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <net/if.h>
+#include <sys/socket.h>
+#include <sys/ioctl.h>
+//#include <bits/libc-lock.h>
+
+/* Try to get a socket to talk to the kernel.  */
+#if defined SIOCGIFINDEX || defined SIOCGIFNAME
+static int
+ internal_function opensock(void)
+{
+	/* Cache the last AF that worked, to avoid many redundant calls to
+	   socket().  */
+	static int sock_af = -1;
+	int fd = -1;
+	__libc_lock_define_initialized(static, lock);
+
+	if (sock_af != -1) {
+		fd = __socket(sock_af, SOCK_DGRAM, 0);
+		if (fd != -1)
+			return fd;
+	}
+
+	__libc_lock_lock(lock);
+
+	if (sock_af != -1)
+		fd = __socket(sock_af, SOCK_DGRAM, 0);
+
+	if (fd == -1) {
+		fd = __socket(sock_af = AF_INET6, SOCK_DGRAM, 0);
+		if (fd < 0)
+			fd = __socket(sock_af = AF_INET, SOCK_DGRAM, 0);
+		if (fd < 0)
+			fd = __socket(sock_af = AF_IPX, SOCK_DGRAM, 0);
+		if (fd < 0)
+			fd = __socket(sock_af = AF_AX25, SOCK_DGRAM, 0);
+		if (fd < 0)
+			fd = __socket(sock_af = AF_APPLETALK, SOCK_DGRAM, 0);
+	}
+
+	__libc_lock_unlock(lock);
+	return fd;
+}
+#endif
+
+unsigned int if_nametoindex(const char *ifname)
+{
+#ifndef SIOCGIFINDEX
+	__set_errno(ENOSYS);
+	return 0;
+#else
+	struct ifreq ifr;
+	int fd = opensock();
+
+	if (fd < 0)
+		return 0;
+
+	strncpy(ifr.ifr_name, ifname, sizeof(ifr.ifr_name));
+	if (__ioctl(fd, SIOCGIFINDEX, &ifr) < 0) {
+		int saved_errno = errno;
+
+		close(fd);
+		if (saved_errno == EINVAL)
+			__set_errno(ENOSYS);
+		return 0;
+	}
+	close(fd);
+	return ifr.ifr_ifindex;
+#endif
+}
+
+void if_freenameindex(struct if_nameindex *ifn)
+{
+	struct if_nameindex *ptr = ifn;
+
+	while (ptr->if_name || ptr->if_index) {
+		if (ptr->if_name)
+			free(ptr->if_name);
+		++ptr;
+	}
+	free(ifn);
+}
+
+struct if_nameindex *if_nameindex(void)
+{
+#ifndef SIOCGIFINDEX
+	__set_errno(ENOSYS);
+	return NULL;
+#else
+	int fd = opensock();
+	struct ifconf ifc;
+	unsigned int nifs, i;
+	int rq_len;
+	struct if_nameindex *idx = NULL;
+	static int old_siocgifconf;
+
+#define RQ_IFS	4
+
+	if (fd < 0)
+		return NULL;
+
+	ifc.ifc_buf = NULL;
+
+	/* We may be able to get the needed buffer size directly, rather than
+	   guessing.  */
+	if (!old_siocgifconf) {
+		ifc.ifc_buf = NULL;
+		ifc.ifc_len = 0;
+		if (__ioctl(fd, SIOCGIFCONF, &ifc) < 0 || ifc.ifc_len == 0) {
+			old_siocgifconf = 1;
+			rq_len = RQ_IFS * sizeof(struct ifreq);
+		} else
+			rq_len = ifc.ifc_len;
+	} else
+		rq_len = RQ_IFS * sizeof(struct ifreq);
+
+	/* Read all the interfaces out of the kernel.  */
+	do {
+		ifc.ifc_buf = alloca(ifc.ifc_len = rq_len);
+		if (ifc.ifc_buf == NULL || __ioctl(fd, SIOCGIFCONF, &ifc) < 0) {
+			close(fd);
+			return NULL;
+		}
+		rq_len *= 2;
+	}
+	while (ifc.ifc_len == rq_len && old_siocgifconf);
+
+	nifs = ifc.ifc_len / sizeof(struct ifreq);
+
+	idx = malloc((nifs + 1) * sizeof(struct if_nameindex));
+	if (idx == NULL) {
+		close(fd);
+		return NULL;
+	}
+
+	for (i = 0; i < nifs; ++i) {
+		struct ifreq *ifr = &ifc.ifc_req[i];
+
+		idx[i].if_name = strdup(ifr->ifr_name);
+		if (idx[i].if_name == NULL || __ioctl(fd, SIOCGIFINDEX, ifr) < 0) {
+			int saved_errno = errno;
+			unsigned int j;
+
+			for (j = 0; j < i; ++j)
+				free(idx[j].if_name);
+			free(idx);
+			close(fd);
+			if (saved_errno == EINVAL)
+				__set_errno(ENOSYS);
+			return NULL;
+		}
+		idx[i].if_index = ifr->ifr_ifindex;
+	}
+
+	idx[i].if_index = 0;
+	idx[i].if_name = NULL;
+
+	close(fd);
+	return idx;
+#endif
+}
+
+char *if_indextoname(unsigned int ifindex, char *ifname)
+{
+#ifndef SIOCGIFINDEX
+	__set_errno(ENOSYS);
+	return NULL;
+#else
+	struct if_nameindex *idx;
+	struct if_nameindex *p;
+	char *result = NULL;
+
+#ifdef SIOCGIFNAME
+	/* We may be able to do the conversion directly, rather than searching a
+	   list.  This ioctl is not present in kernels before version 2.1.50.  */
+	struct ifreq ifr;
+	int fd;
+	static int siocgifname_works_not;
+
+	if (!siocgifname_works_not) {
+		int serrno = errno;
+
+		fd = opensock();
+
+		if (fd < 0)
+			return NULL;
+
+		ifr.ifr_ifindex = ifindex;
+		if (__ioctl(fd, SIOCGIFNAME, &ifr) < 0) {
+			if (errno == EINVAL)
+				siocgifname_works_not = 1;	/* Don't make the same mistake twice. */
+		} else {
+			close(fd);
+			return strncpy(ifname, ifr.ifr_name, IFNAMSIZ);
+		}
+
+		close(fd);
+
+		__set_errno(serrno);
+	}
+#endif
+
+	idx = if_nameindex();
+
+	if (idx != NULL) {
+		for (p = idx; p->if_index || p->if_name; ++p)
+			if (p->if_index == ifindex) {
+				result = strncpy(ifname, p->if_name, IFNAMSIZ);
+				break;
+			}
+
+		if_freenameindex(idx);
+	}
+	return result;
+#endif
+}
--- busybox-1.00-pre4.ORIG/networking/libbridge/libbridge_compat.c	1969-12-31 18:00:00.000000000 -0600
+++ busybox-1.00-pre4/networking/libbridge/libbridge_compat.c	2003-12-17 11:06:20.000000000 -0600
@@ -0,0 +1,35 @@
+/*
+ * Compatability glue for systems lacking the if_nametoindex and
+ * if_indextoname functions.
+ *
+ * The file 'if_index.c' was taken verbatimly from the GNU C Library
+ * version 2.1 (990920) and is Copyright (C) 1997, 1998, 1999 Free
+ * Software Foundation, Inc.
+ */
+
+/*
+ * On how to use this file: Serge Caron writes:
+ *
+ * I installed compat-glibc-6.2-2.1.3.2.i386.rpm in my Red Hat 5.2 box
+ *
+ * from the directory where libbridge is stored I ran
+ *
+ * gcc -Wall -g -nostdinc -I- -I.
+ *   -I /usr/i386-glibc21-linux/include
+ *   -I /usr/lib/gcc-lib/i386-redhat-linux/2.7.23/include
+ *   -c libbridge_compat.c
+ *
+ * Now this gives a nice .o file that keeps make happy. Running make in the top
+ * directory builds brctl and brctld against glibc-2.0.7.
+ */
+
+#define _BITS_LIBC_LOCK_H 1
+#define __libc_lock_define_initialized(a,b)
+#define __libc_lock_lock(a)
+#define __libc_lock_unlock(a)
+#define __ioctl ioctl
+#define __set_errno(a) {errno = (a);}
+#define __socket socket
+#define internal_function
+
+#include "if_index.c"
--- busybox-1.00-pre4.ORIG/networking/libbridge/libbridge_devif.c	1969-12-31 18:00:00.000000000 -0600
+++ busybox-1.00-pre4/networking/libbridge/libbridge_devif.c	2003-12-17 11:06:20.000000000 -0600
@@ -0,0 +1,203 @@
+/*
+ * Copyright (C) 2000 Lennert Buytenhek
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <string.h>
+#include <sys/fcntl.h>
+#include <sys/ioctl.h>
+#include <sys/time.h>
+#include "libbridge.h"
+#include "libbridge_private.h"
+
+int br_device_ioctl32(struct bridge *br, unsigned long arg0,
+					  unsigned long arg1, unsigned long arg2,
+					  unsigned long arg3)
+{
+	unsigned long args[4];
+	struct ifreq ifr;
+
+	args[0] = arg0;
+	args[1] = arg1;
+	args[2] = arg2;
+	args[3] = arg3;
+
+	memcpy(ifr.ifr_name, br->ifname, IFNAMSIZ);
+	((unsigned long *) (&ifr.ifr_data))[0] = (unsigned long) args;
+
+	return ioctl(br_socket_fd, SIOCDEVPRIVATE, &ifr);
+}
+
+#ifdef __sparc__
+int br_device_ioctl64(struct bridge *br, unsigned long arg0,
+					  unsigned long arg1, unsigned long arg2,
+					  unsigned long arg3)
+{
+	unsigned long long args[4];
+	struct ifreq ifr;
+
+	args[0] = arg0;
+	args[1] = arg1;
+	args[2] = arg2;
+	args[3] = arg3;
+
+	memcpy(ifr.ifr_name, br->ifname, IFNAMSIZ);
+	((unsigned long long *) (&ifr.ifr_data))[0] =
+		(unsigned long long) (unsigned long) args;
+
+	return ioctl(br_socket_fd, SIOCDEVPRIVATE + 3, &ifr);
+}
+#endif
+
+int br_device_ioctl(struct bridge *br, unsigned long arg0, unsigned long arg1,
+					unsigned long arg2, unsigned long arg3)
+{
+#ifdef __sparc__
+	if (__kernel_is_64_bit())
+		return br_device_ioctl64(br, arg0, arg1, arg2, arg3);
+#endif
+
+	return br_device_ioctl32(br, arg0, arg1, arg2, arg3);
+}
+
+int br_add_interface(struct bridge *br, int ifindex)
+{
+	if (br_device_ioctl(br, BRCTL_ADD_IF, ifindex, 0, 0) < 0)
+		return errno;
+
+	return 0;
+}
+
+int br_del_interface(struct bridge *br, int ifindex)
+{
+	if (br_device_ioctl(br, BRCTL_DEL_IF, ifindex, 0, 0) < 0)
+		return errno;
+
+	return 0;
+}
+
+int br_set_bridge_forward_delay(struct bridge *br, struct timeval *tv)
+{
+	unsigned long jif = __tv_to_jiffies(tv);
+
+	if (br_device_ioctl(br, BRCTL_SET_BRIDGE_FORWARD_DELAY, jif, 0, 0) < 0)
+		return errno;
+
+	return 0;
+}
+
+int br_set_bridge_hello_time(struct bridge *br, struct timeval *tv)
+{
+	unsigned long jif = __tv_to_jiffies(tv);
+
+	if (br_device_ioctl(br, BRCTL_SET_BRIDGE_HELLO_TIME, jif, 0, 0) < 0)
+		return errno;
+
+	return 0;
+}
+
+int br_set_bridge_max_age(struct bridge *br, struct timeval *tv)
+{
+	unsigned long jif = __tv_to_jiffies(tv);
+
+	if (br_device_ioctl(br, BRCTL_SET_BRIDGE_MAX_AGE, jif, 0, 0) < 0)
+		return errno;
+
+	return 0;
+}
+
+int br_set_ageing_time(struct bridge *br, struct timeval *tv)
+{
+	unsigned long jif = __tv_to_jiffies(tv);
+
+	if (br_device_ioctl(br, BRCTL_SET_AGEING_TIME, jif, 0, 0) < 0)
+		return errno;
+
+	return 0;
+}
+
+int br_set_gc_interval(struct bridge *br, struct timeval *tv)
+{
+	unsigned long jif = __tv_to_jiffies(tv);
+
+	if (br_device_ioctl(br, BRCTL_SET_GC_INTERVAL, jif, 0, 0) < 0)
+		return errno;
+
+	return 0;
+}
+
+int br_set_stp_state(struct bridge *br, int stp_state)
+{
+	if (br_device_ioctl(br, BRCTL_SET_BRIDGE_STP_STATE, stp_state, 0, 0) < 0)
+		return errno;
+
+	return 0;
+}
+
+int br_set_bridge_priority(struct bridge *br, int bridge_priority)
+{
+	if (br_device_ioctl(br, BRCTL_SET_BRIDGE_PRIORITY, bridge_priority,
+						0, 0) < 0)
+		return errno;
+
+	return 0;
+}
+
+int br_set_port_priority(struct port *p, int port_priority)
+{
+	if (br_device_ioctl(p->parent, BRCTL_SET_PORT_PRIORITY, p->index,
+						port_priority, 0) < 0)
+		return errno;
+
+	return 0;
+}
+
+int br_set_path_cost(struct port *p, int path_cost)
+{
+	if (br_device_ioctl(p->parent, BRCTL_SET_PATH_COST, p->index,
+						path_cost, 0) < 0)
+		return errno;
+
+	return 0;
+}
+
+void __copy_fdb(struct fdb_entry *ent, struct __fdb_entry *f)
+{
+	memcpy(ent->mac_addr, f->mac_addr, 6);
+	ent->port_no = f->port_no;
+	ent->is_local = f->is_local;
+	__jiffies_to_tv(&ent->ageing_timer_value, f->ageing_timer_value);
+}
+
+int br_read_fdb(struct bridge *br, struct fdb_entry *fdbs, int offset,
+				int num)
+{
+	struct __fdb_entry f[num];
+	int i;
+	int numread;
+
+	if ((numread = br_device_ioctl(br, BRCTL_GET_FDB_ENTRIES,
+								   (unsigned long) f, num, offset)) < 0)
+		return errno;
+
+	for (i = 0; i < numread; i++)
+		__copy_fdb(fdbs + i, f + i);
+
+	return numread;
+}
--- busybox-1.00-pre4.ORIG/networking/libbridge/libbridge.h	1969-12-31 18:00:00.000000000 -0600
+++ busybox-1.00-pre4/networking/libbridge/libbridge.h	2003-12-17 11:06:20.000000000 -0600
@@ -0,0 +1,127 @@
+/*
+ * Copyright (C) 2000 Lennert Buytenhek
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef _LIBBRIDGE_H
+#define _LIBBRIDGE_H
+
+#include <net/if.h>
+#include <linux/if_bridge.h>
+
+struct bridge;
+struct bridge_info;
+struct fdb_entry;
+struct port;
+struct port_info;
+
+struct bridge_id {
+	unsigned char prio[2];
+	unsigned char addr[6];
+};
+
+struct bridge_info {
+	struct bridge_id designated_root;
+	struct bridge_id bridge_id;
+	int root_path_cost;
+	struct timeval max_age;
+	struct timeval hello_time;
+	struct timeval forward_delay;
+	struct timeval bridge_max_age;
+	struct timeval bridge_hello_time;
+	struct timeval bridge_forward_delay;
+	unsigned topology_change:1;
+	unsigned topology_change_detected:1;
+	int root_port;
+	unsigned stp_enabled:1;
+	struct timeval ageing_time;
+	struct timeval gc_interval;
+	struct timeval hello_timer_value;
+	struct timeval tcn_timer_value;
+	struct timeval topology_change_timer_value;
+	struct timeval gc_timer_value;
+};
+
+struct bridge {
+	struct bridge *next;
+
+	int ifindex;
+	char ifname[IFNAMSIZ];
+	struct port *firstport;
+	struct port *ports[256];
+	struct bridge_info info;
+};
+
+struct fdb_entry {
+	u_int8_t mac_addr[6];
+	int port_no;
+	unsigned is_local:1;
+	struct timeval ageing_timer_value;
+};
+
+struct port_info {
+	struct bridge_id designated_root;
+	struct bridge_id designated_bridge;
+	u_int16_t port_id;
+	u_int16_t designated_port;
+	int path_cost;
+	int designated_cost;
+	int state;
+	unsigned top_change_ack:1;
+	unsigned config_pending:1;
+	struct timeval message_age_timer_value;
+	struct timeval forward_delay_timer_value;
+	struct timeval hold_timer_value;
+};
+
+struct port {
+	struct port *next;
+
+	int index;
+	int ifindex;
+	struct bridge *parent;
+	struct port_info info;
+};
+
+extern struct bridge *bridge_list;
+
+int br_init(void);
+int br_refresh(void);
+struct bridge *br_find_bridge(char *brname);
+struct port *br_find_port(struct bridge *br, char *portname);
+char *br_get_state_name(int state);
+
+int br_add_bridge(char *brname);
+int br_del_bridge(char *brname);
+int br_add_interface(struct bridge *br, int ifindex);
+int br_del_interface(struct bridge *br, int ifindex);
+int br_set_bridge_forward_delay(struct bridge *br, struct timeval *tv);
+int br_set_bridge_hello_time(struct bridge *br, struct timeval *tv);
+int br_set_bridge_max_age(struct bridge *br, struct timeval *tv);
+int br_set_ageing_time(struct bridge *br, struct timeval *tv);
+int br_set_gc_interval(struct bridge *br, struct timeval *tv);
+int br_set_stp_state(struct bridge *br, int stp_state);
+int br_set_bridge_priority(struct bridge *br, int bridge_priority);
+int br_set_port_priority(struct port *p, int port_priority);
+int br_set_path_cost(struct port *p, int path_cost);
+int br_read_fdb(struct bridge *br, struct fdb_entry *fdbs, int offset,
+				int num);
+
+/* libc5 combatability */
+char *if_indextoname(unsigned int __ifindex, char *__ifname);
+unsigned int if_nametoindex(const char *__ifname);
+
+#endif
--- busybox-1.00-pre4.ORIG/networking/libbridge/libbridge_if.c	1969-12-31 18:00:00.000000000 -0600
+++ busybox-1.00-pre4/networking/libbridge/libbridge_if.c	2003-12-17 11:06:20.000000000 -0600
@@ -0,0 +1,105 @@
+/*
+ * Copyright (C) 2000 Lennert Buytenhek
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <string.h>
+#include <sys/fcntl.h>
+#include <sys/ioctl.h>
+#include <sys/time.h>
+#include <sys/utsname.h>
+#include "libbridge.h"
+#include "libbridge_private.h"
+
+static int br_ioctl32(unsigned long arg0, unsigned long arg1,
+					  unsigned long arg2)
+{
+	unsigned long arg[3];
+
+	arg[0] = arg0;
+	arg[1] = arg1;
+	arg[2] = arg2;
+
+	return ioctl(br_socket_fd, SIOCGIFBR, arg);
+}
+
+#ifdef __sparc__
+static int br_ioctl64(unsigned long arg0, unsigned long arg1,
+					  unsigned long arg2)
+{
+	unsigned long long arg[3];
+
+	arg[0] = arg0;
+	arg[1] = arg1;
+	arg[2] = arg2;
+
+	return ioctl(br_socket_fd, SIOCGIFBR, arg);
+}
+
+int __kernel_is_64_bit()
+{
+	static int kernel_is_64_bit = -1;
+
+	if (kernel_is_64_bit == -1) {
+		struct utsname buf;
+
+		uname(&buf);
+		kernel_is_64_bit = !strcmp(buf.machine, "sparc64");
+	}
+
+	return kernel_is_64_bit;
+}
+#endif
+
+int br_ioctl(unsigned long arg0, unsigned long arg1, unsigned long arg2)
+{
+#ifdef __sparc__
+	if (__kernel_is_64_bit())
+		return br_ioctl64(arg0, arg1, arg2);
+#endif
+
+	return br_ioctl32(arg0, arg1, arg2);
+}
+
+int br_get_version()
+{
+	return br_ioctl(BRCTL_GET_VERSION, 0, 0);
+}
+
+int br_add_bridge(char *brname)
+{
+	char _br[IFNAMSIZ];
+
+	memcpy(_br, brname, IFNAMSIZ);
+	if (br_ioctl(BRCTL_ADD_BRIDGE, (unsigned long) _br, 0) < 0)
+		return errno;
+
+	return 0;
+}
+
+int br_del_bridge(char *brname)
+{
+	char _br[IFNAMSIZ];
+
+	memcpy(_br, brname, IFNAMSIZ);
+	if (br_ioctl(BRCTL_DEL_BRIDGE, (unsigned long) _br, 0) < 0)
+		return errno;
+
+	return 0;
+}
--- busybox-1.00-pre4.ORIG/networking/libbridge/libbridge_init.c	1969-12-31 18:00:00.000000000 -0600
+++ busybox-1.00-pre4/networking/libbridge/libbridge_init.c	2003-12-17 11:06:20.000000000 -0600
@@ -0,0 +1,225 @@
+/*
+ * Copyright (C) 2000 Lennert Buytenhek
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <string.h>
+#include <sys/fcntl.h>
+#include <sys/ioctl.h>
+#include <sys/time.h>
+#include "libbridge.h"
+#include "libbridge_private.h"
+
+int br_socket_fd;
+struct bridge *bridge_list;
+
+static void __bridge_info_copy(struct bridge_info *info,
+							   struct __bridge_info *i)
+{
+	memcpy(&info->designated_root, &i->designated_root, 8);
+	memcpy(&info->bridge_id, &i->bridge_id, 8);
+	info->root_path_cost = i->root_path_cost;
+	info->topology_change = i->topology_change;
+	info->topology_change_detected = i->topology_change_detected;
+	info->root_port = i->root_port;
+	info->stp_enabled = i->stp_enabled;
+	__jiffies_to_tv(&info->max_age, i->max_age);
+	__jiffies_to_tv(&info->hello_time, i->hello_time);
+	__jiffies_to_tv(&info->forward_delay, i->forward_delay);
+	__jiffies_to_tv(&info->bridge_max_age, i->bridge_max_age);
+	__jiffies_to_tv(&info->bridge_hello_time, i->bridge_hello_time);
+	__jiffies_to_tv(&info->bridge_forward_delay, i->bridge_forward_delay);
+	__jiffies_to_tv(&info->ageing_time, i->ageing_time);
+	__jiffies_to_tv(&info->gc_interval, i->gc_interval);
+	__jiffies_to_tv(&info->hello_timer_value, i->hello_timer_value);
+	__jiffies_to_tv(&info->tcn_timer_value, i->tcn_timer_value);
+	__jiffies_to_tv(&info->topology_change_timer_value,
+					i->topology_change_timer_value);
+	__jiffies_to_tv(&info->gc_timer_value, i->gc_timer_value);
+}
+
+static void __port_info_copy(struct port_info *info, struct __port_info *i)
+{
+	memcpy(&info->designated_root, &i->designated_root, 8);
+	memcpy(&info->designated_bridge, &i->designated_bridge, 8);
+	info->port_id = i->port_id;
+	info->designated_port = i->designated_port;
+	info->path_cost = i->path_cost;
+	info->designated_cost = i->designated_cost;
+	info->state = i->state;
+	info->top_change_ack = i->top_change_ack;
+	info->config_pending = i->config_pending;
+	__jiffies_to_tv(&info->message_age_timer_value,
+					i->message_age_timer_value);
+	__jiffies_to_tv(&info->forward_delay_timer_value,
+					i->forward_delay_timer_value);
+	__jiffies_to_tv(&info->hold_timer_value, i->hold_timer_value);
+}
+
+int br_read_info(struct bridge *br)
+{
+	struct __bridge_info i;
+
+	if (if_indextoname(br->ifindex, br->ifname) == NULL)
+		return 1;
+
+	if (br_device_ioctl(br, BRCTL_GET_BRIDGE_INFO,
+						(unsigned long) &i, 0, 0) < 0)
+		return 1;
+
+	__bridge_info_copy(&br->info, &i);
+	return 0;
+}
+
+int br_read_port_info(struct port *p)
+{
+	struct __port_info i;
+
+	if (br_device_ioctl(p->parent, BRCTL_GET_PORT_INFO,
+						(unsigned long) &i, p->index, 0) < 0)
+		return errno;
+
+	__port_info_copy(&p->info, &i);
+	return 0;
+}
+
+void br_nuke_bridge(struct bridge *b)
+{
+	struct port *p;
+
+	p = b->firstport;
+	while (p != NULL) {
+		struct port *pnext;
+
+		pnext = p->next;
+		free(p);
+		p = pnext;
+	}
+
+	free(b);
+}
+
+int br_make_port_list(struct bridge *br)
+{
+	int err;
+	int i;
+	int ifindices[256];
+
+	if (br_device_ioctl(br, BRCTL_GET_PORT_LIST, (unsigned long) ifindices,
+						0, 0) < 0)
+		return errno;
+
+	for (i = 255; i >= 0; i--) {
+		struct port *p;
+
+		if (!ifindices[i])
+			continue;
+
+		p = malloc(sizeof(struct port));
+		p->index = i;
+		p->ifindex = ifindices[i];
+		p->parent = br;
+		br->ports[i] = p;
+		p->next = br->firstport;
+		br->firstport = p;
+		if ((err = br_read_port_info(p)) != 0)
+			goto error_out;
+	}
+
+	return 0;
+
+  error_out:
+	while (++i < 256)
+		free(br->ports[i]);
+
+	return err;
+}
+
+int br_make_bridge_list()
+{
+	int err;
+	int i;
+	int ifindices[32];
+	int num;
+
+	num = br_ioctl(BRCTL_GET_BRIDGES, (unsigned long) ifindices, 32);
+	if (num < 0)
+		return errno;
+
+	bridge_list = NULL;
+	for (i = 0; i < num; i++) {
+		struct bridge *br;
+
+		br = malloc(sizeof(struct bridge));
+		memset(br, 0, sizeof(struct bridge));
+		br->ifindex = ifindices[i];
+		br->firstport = NULL;
+		br->next = bridge_list;
+		bridge_list = br;
+		if ((err = br_read_info(br)) != 0)
+			goto error_out;
+		if ((err = br_make_port_list(br)) != 0)
+			goto error_out;
+	}
+
+	return 0;
+
+  error_out:
+	while (bridge_list != NULL) {
+		struct bridge *nxt;
+
+		nxt = bridge_list->next;
+		br_nuke_bridge(bridge_list);
+		bridge_list = nxt;
+	}
+
+	return err;
+}
+
+int br_init()
+{
+	int err;
+
+	if ((br_socket_fd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
+		return errno;
+
+	if (br_get_version() != BRCTL_VERSION)
+		return 12345;
+
+	if ((err = br_make_bridge_list()) != 0)
+		return err;
+
+	return 0;
+}
+
+int br_refresh()
+{
+	struct bridge *b;
+
+	b = bridge_list;
+	while (b != NULL) {
+		struct bridge *bnext;
+
+		bnext = b->next;
+		br_nuke_bridge(b);
+		b = bnext;
+	}
+
+	return br_make_bridge_list();
+}
--- busybox-1.00-pre4.ORIG/networking/libbridge/libbridge_misc.c	1969-12-31 18:00:00.000000000 -0600
+++ busybox-1.00-pre4/networking/libbridge/libbridge_misc.c	2003-12-17 11:06:20.000000000 -0600
@@ -0,0 +1,88 @@
+/*
+ * Copyright (C) 2000 Lennert Buytenhek
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/time.h>
+#include <asm/param.h>
+#include "libbridge.h"
+#include "libbridge_private.h"
+
+unsigned long __tv_to_jiffies(struct timeval *tv)
+{
+	unsigned long long jif;
+
+	jif = 1000000ULL * tv->tv_sec + tv->tv_usec;
+
+	return (HZ * jif) / 1000000;
+}
+
+void __jiffies_to_tv(struct timeval *tv, unsigned long jiffies)
+{
+	unsigned long long tvusec;
+
+	tvusec = (1000000ULL * jiffies) / HZ;
+	tv->tv_sec = tvusec / 1000000;
+	tv->tv_usec = tvusec - 1000000 * tv->tv_sec;
+}
+
+static char *state_names[5] =
+	{ "disabled", "listening", "learning", "forwarding", "blocking" };
+
+char *br_get_state_name(int state)
+{
+	if (state >= 0 && state <= 4)
+		return state_names[state];
+
+	return "<INVALID STATE>";
+}
+
+struct bridge *br_find_bridge(char *brname)
+{
+	struct bridge *b;
+
+	b = bridge_list;
+	while (b != NULL) {
+		if (!strcmp(b->ifname, brname))
+			return b;
+
+		b = b->next;
+	}
+
+	return NULL;
+}
+
+struct port *br_find_port(struct bridge *br, char *portname)
+{
+	char if_index;
+	struct port *p;
+
+	if (!(if_index = if_nametoindex(portname)))
+		return NULL;
+
+	p = br->firstport;
+	while (p != NULL) {
+		if (p->ifindex == if_index)
+			return p;
+
+		p = p->next;
+	}
+
+	return NULL;
+}
--- busybox-1.00-pre4.ORIG/networking/libbridge/libbridge_private.h	1969-12-31 18:00:00.000000000 -0600
+++ busybox-1.00-pre4/networking/libbridge/libbridge_private.h	2003-12-17 11:06:20.000000000 -0600
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2000 Lennert Buytenhek
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef _LIBBRIDGE_PRIVATE_H
+#define _LIBBRIDGE_PRIVATE_H
+
+#include <asm/param.h>
+
+extern int br_socket_fd;
+
+void __jiffies_to_tv(struct timeval *tv, unsigned long jiffies);
+int __kernel_is_64_bit(void);
+unsigned long __tv_to_jiffies(struct timeval *tv);
+
+int br_device_ioctl(struct bridge *br,
+					unsigned long arg0,
+					unsigned long arg1,
+					unsigned long arg2, unsigned long arg3);
+int br_get_version(void);
+int br_ioctl(unsigned long arg0, unsigned long arg1, unsigned long arg2);
+int br_make_bridge_list(void);
+int br_make_port_list(struct bridge *br);
+int br_read_info(struct bridge *br);
+int br_read_port_info(struct port *p);
+
+#endif
--- busybox-1.00-pre4.ORIG/networking/libbridge/Makefile	1969-12-31 18:00:00.000000000 -0600
+++ busybox-1.00-pre4/networking/libbridge/Makefile	2003-12-17 11:06:20.000000000 -0600
@@ -0,0 +1,30 @@
+# Makefile for busybox
+#
+# Copyright (C) 1999-2002 Erik Andersen <andersee@debian.org>
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+# General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+#
+
+top_srcdir:= ../../
+LIBBRIDGE_DIR:=./
+include $(top_srcdir).config
+include $(top_srcdir)Rules.mak
+include Makefile.in
+all: $(libraries-y)
+-include $(top_srcdir).depend
+
+clean:
+	rm -f *.o *.a $(AR_TARGET)
+
--- busybox-1.00-pre4.ORIG/networking/libbridge/Makefile.in	1969-12-31 18:00:00.000000000 -0600
+++ busybox-1.00-pre4/networking/libbridge/Makefile.in	2003-12-17 11:06:20.000000000 -0600
@@ -0,0 +1,47 @@
+# Makefile for busybox
+#
+# Copyright (C) 1999-2002 by Erik Andersen <andersee@debian.org>
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+# General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+#
+
+LIBBRIDGE_AR:=libbridge.a
+ifndef $(LIBBRIDGE_DIR)
+LIBBRIDGE_DIR:=$(top_srcdir)/networking/libbridge/
+endif
+
+ifndef HAVE_IF_INDEX
+COMPAT_SOURCES=  \
+	libbridge_compat.c 
+else
+COMPAT_SOURCES=  
+endif
+
+LIBBRIDGE_SOURCES= \
+	$(COMPAT_SOURCES) \
+	libbridge_devif.c \
+	libbridge_if.c \
+	libbridge_init.c \
+	libbridge_misc.c 
+
+LIBBRIDGE-$(CONFIG_BRCTL)+=$(LIBBRIDGE_SOURCES:.c=.o)
+
+libraries-y+=$(LIBBRIDGE_DIR)$(LIBBRIDGE_AR)
+
+$(LIBBRIDGE_DIR)$(LIBBRIDGE_AR): $(patsubst %,$(LIBBRIDGE_DIR)%, $(LIBBRIDGE-y))
+	$(AR) -ro $@ $(patsubst %,$(LIBBRIDGE_DIR)%, $(LIBBRIDGE-y))
+
+libbridge_compat.o:	libbridge_compat.c if_index.c
+	$(CC) $(CFLAGS) -c libbridge_compat.c
--- busybox-1.00-pre4.ORIG/networking/Makefile.in	2003-07-28 02:40:37.000000000 -0500
+++ busybox-1.00-pre4/networking/Makefile.in	2003-12-17 11:06:20.000000000 -0600
@@ -24,6 +24,7 @@
 
 NETWORKING-y:=
 NETWORKING-$(CONFIG_ARPING)	+= arping.o
+NETWORKING-$(CONFIG_BRCTL)	+= brctl.o
 NETWORKING-$(CONFIG_FTPGET)	+= ftpgetput.o
 NETWORKING-$(CONFIG_FTPPUT)	+= ftpgetput.o
 NETWORKING-$(CONFIG_HOSTNAME)	+= hostname.o
